#version 450 core

// multiple render targets - renders to AlphaBuffer
layout(location = 0) out vec4 Accum;
layout(location = 1) out float Reveal;

in VS_OUT {
    vec3 fragPosition;
    vec3 fragNormal;
    vec2 texCoords;
    flat int materialNumber;
} fs_in;

// imports
##[fragments/materialData] //! #include "fragments/materialData.gem"
##[fragments/textureData] //! #include "fragments/textureData.gem"


uniform sampler2DArray textureLib;

uniform mat4 inverseViewMat;

uniform vec3 cameraPos;
uniform vec3 lightPos;


void main() {
    vec3 fragPosition = (inverseViewMat * vec4(fs_in.fragPosition, 1.0)).xyz;

    Material mat = materialTable[fs_in.materialNumber];
    Texture tex = textureTable[mat.textureId];
    TextureView diffuseView = textureViewTable[tex.textureViewId];
    //TextureView normalsView = textureViewTable[tex.textureViewId + normals_unit_index];
    TextureView specularView = textureViewTable[tex.textureViewId + specular_unit_index];

    vec3 lightColor = vec3(1.0);
    vec3 ambient = vec3(0.6);
    
    // diffuse
    vec3 texCoords = vec3(fs_in.texCoords, 0);
    vec3 diffuseCoords = getTexUnitCoords(textureLib, texCoords, diffuseView, diffuse_unit_index);
    vec3 diffuse = texture(textureLib, diffuseCoords).rgb;

    float specFactor = 0.8;
    if (vec2(specularView.wDelta, specularView.hDelta) != vec2(0.0)){ // specular map exists?
        vec3 specularCoords = getTexUnitCoords(textureLib, texCoords, specularView, specular_unit_index);
        specFactor = texture(textureLib, specularCoords).r;
    }
    else 
        specFactor = 0.8;
    
    vec3 viewDir    = normalize(cameraPos - fragPosition);
    vec3 lightDir = normalize(lightPos - fragPosition);
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(fs_in.fragNormal, halfwayDir), 0.0), 64.0);
    vec3 specular = specFactor * spec * lightColor;
    
    vec4 color = vec4((ambient + diffuse + specular) * texture(textureLib, diffuseCoords).rgb, mat.opacity);
    
    
    // weight function
    float weight = clamp(pow(min(1.0, color.a * 10.0) + 0.01, 3.0) * 1e8 * 
                         pow(1.0 - gl_FragCoord.z * 0.9, 3.0), 1e-2, 3e3);

    // store pixel color accumulation and pixel revealage threshold
    Accum = vec4(color.rgb * color.a, color.a) * weight;
    Reveal = color.a;
}